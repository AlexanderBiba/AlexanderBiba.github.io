// This file is auto-generated by scripts/build-posts.js
// Do not edit manually

import { BlogPost } from './types'

export const posts: BlogPost[] = [
  {
    "slug": "firebase-vercel-supabase",
    "title": "Moving from Firebase to Vercel + Supabase",
    "date": "2025-12-09",
    "description": "",
    "ogImage": null,
    "content": "\nI’ve been using Firebase for a few years, building several web apps on top of it. Firebase is excellent for moving fast: it gives you a backend, auth, storage, and hosting in one place so you can focus on the product. What I’ve valued most:\n\n- Easy-to-use, scalable document database (Firestore)  \n- Storage with a built-in CDN  \n- Hosting with a deployment pipeline directly connected to GitHub  \n\nIt makes it effortless to build a React or Next.js app without thinking about infrastructure. And because it runs on Google Cloud, scaling is never the bottleneck.\n\nBut after building applications for clients, I ran into concerns that pushed me to rethink the stack.\n\n---\n\n## The Problem With Firebase for Client Projects\n\nFirebase is amazing for side projects, prototypes, and internal tools. The issues surface when you deploy something for a client—and you need predictable, controllable costs.\n\n**The biggest issue: Firebase has no hard billing cap.**\n\n- On the Blaze (pay-as-you-go) plan, you can set budget alerts, but alerts do *not* stop usage.  \n- A traffic spike, infinite loop, misconfigured client, or DDOS attack can push your bill up with no automatic safeguard.  \n- This is a long-standing limitation across Firebase and Google Cloud.\n\nThere are workaround scripts that attempt to shut down billing accounts when alerts trigger, but they’re unreliable and can break production systems. For client apps, that level of financial risk is hard to justify.\n\nThis led me to look for alternatives where cost exposure is easier to control.\n\n---\n\n## Why Supabase Was a Better Fit\n\nSupabase is a managed backend built on Postgres and AWS (plus Fly.io for some compute), offering SQL databases, storage, authentication, edge functions, and more. A few advantages stood out immediately:\n\n### **Hard Spend Cap**\nSupabase allows you to enable a spend cap on paid plans.  \nWhen enabled:\n\n- Your project stops scaling past its plan limits  \n- Certain usage categories stop rather than charging more  \n- You avoid runaway billing\n\nIt’s not a global cap on *every* possible expansion (e.g., manually added add-ons), but it dramatically reduces exposure compared to Firebase.\n\n### **Postgres**\nA full relational database with:\n\n- schemas  \n- constraints  \n- migrations  \n- SQL  \n- predictable queries  \n\nThis is a significant upgrade over a NoSQL document database once your data model grows.\n\n### **Storage With SQL-Style Policies**\nSupabase storage sits behind Postgres row-level policies, making the rules easier to reason about than Firebase’s custom rules language.\n\n### **Smooth Onboarding**\nThe free tier lets you launch two projects with storage and a proper Postgres instance—ideal for early development.\n\n---\n\n## Migration Experience\n\nMigrating my client apps was straightforward. Most of their data involved media files (images, audio, videos), which mapped cleanly into Supabase buckets. Postgres made relational data, backups, and exports easier using standard tools like `pg_dump`.\n\nYou do need to design schemas and think relationally—but that’s part of what makes the system more robust long-term.\n\n---\n\n## Deployments With Vercel\n\nI paired Supabase with Vercel for deployments. The experience has been smooth:\n\n- Automatic deployments on every GitHub push  \n- Preview URLs on pull requests  \n- Straightforward environment variable management  \n- Built-in serverless and edge functions  \n- A generous free tier that works well for multiple small projects  \n\nVercel + Supabase is a natural fit, especially for Next.js apps. The stack is modern, scalable, and easier to reason about than Firebase once you move past prototypes.\n\n---\n\n## Firebase vs. Supabase + Vercel: Feature Comparison\n\n| Feature | Firebase | Supabase | Vercel |\n|--------|----------|----------|--------|\n| **Database** | Firestore (NoSQL) | Postgres | N/A |\n| **Hard Billing Cap** | ❌ | ✔️ (for capped resources) | ✔️ (per-project limits) |\n| **Auth** | ✔️ | ✔️ | Third-party or custom |\n| **Storage** | ✔️ CDN | ✔️ with SQL policies | Integrations / edge storage |\n| **Functions** | Cloud Functions | Edge Functions | Serverless / Edge Functions |\n| **Git Deploy** | Partial | N/A | ✔️ |\n| **Pricing Predictability** | Low | High (with spend cap enabled) | High |\n\n---\n\n## Conclusion\n\nFirebase is fantastic for rapid prototyping and personal apps. But for client projects, the lack of a true hard billing cap introduces financial risk that’s difficult to justify.\n\nSupabase + Vercel offers:\n\n- more predictable cost structure,  \n- a powerful relational database,  \n- strong developer ergonomics, and  \n- modern deployment workflows.\n\nYou still need to understand how Supabase’s spend caps work and what’s covered, but overall it’s a safer, more controllable setup for production work.\n\nIf you’re building real applications for clients or planning to scale, the Vercel + Supabase combination has been a reliable choice so far.\n"
  },
  {
    "slug": "cursor-experience",
    "title": "My Experience with Cursor",
    "date": "2025-11-02",
    "description": "",
    "ogImage": null,
    "content": "\nI’ve been writing code since I was a teen. Autocompletion has been a constant companion, and I was genuinely impressed when GitHub Copilot arrived, offering context-aware, AI-driven suggestions.\n\nTo be honest, I was a latecomer to the \"vibe coding\" hype train. When my workplace provided us with Cursor licenses, I was initially skeptical. I felt more productive sticking to my traditional, \"old-fashioned\" way of writing code, and, frankly, I didn't want to risk my project deadlines on a new tool.\n\nHowever, things changed during my paternity leave. I decided to dedicate some time to truly learn how to \"vibe code,\" and I was absolutely blown away. Below is my experience.\n\n## Project 1: Personal Website (React/GitHub Pages)\n\nMy first task was improving my [personal website](https://alexanderbiba.github.io/), a small React application hosted on GitHub Pages. I was hooked from the very first prompt:\n\n> “This is my personal website; it looks a bit dated. Can we make it look modern and cool? Specifically, I would like a retro-futuristic theme and a dark mode/light mode button.”\n\n![](mysite-futuristic.png)\n\nThe initial result was... okay. A little infantile, perhaps, as \"retro-futuristic\" wasn't quite my style. But in that moment, I understood the agent's potential. My next prompt was:\n\n> \"Actually, make it more professional, minimalistic, and concise, while still surfacing the most relevant information.\"\n\nI followed up with more specific requests:\n\n- \"this section is unnecessary\"\n- \"make the experience part card-based\"\n- \"let’s try a dark style\"\n\nAfter several rounds of back-and-forth, I reached an outcome I was satisfied with. Crucially, the process itself was fun, allowing me to experiment with different styles, prompts, and ideas.\n\n|         Before         |         After         |\n| :--------------------: | :-------------------: |\n| ![](mysite-before.png) | ![](mysite-after.png) |\n\n---\n\n## Project 2: Wordle Clone (React/Firebase)\n\nThe next project was a slightly more complex React/Firebase application, a [Wordle clone](https://alexanderbiba.github.io/wordle/). Here, I moved beyond just style updates (though it definitely got a facelift) to adding substantial new features. The basic app was bare-bones: a daily word, five attempts, all stored in browser cache. With the AI agent, I was able to implement:\n\n- **Profiles:** Sign-in functionality using a Google account.\n- **End-of-Game Statistics:** Metrics like games played, current streak, win percentage, and guess distribution.\n- **Leaderboard:** Displaying leaders across the above statistics.\n- **Information:** Game instructions and an \"About\" section.\n\nThe agent was even helpful with backend configuration, guiding me on which Firebase settings needed updating to support the new login flow.\n\n|         Before         |         After         |\n| :--------------------: | :-------------------: |\n| ![](wordle-before.png) | ![](wordle-after.png) |\n\nDespite these awesome features, this is where I started encountering quirks:\n\n- **Minor CSS Glitches:** The initial dark mode button worked, but when zoomed out, white bars appeared where the page should have been dark.\n- **Feature Implementation Complexity:** Redesigning the keyboard took several attempts; the agent initially placed it outside the card, then created two keyboards.\n- **Data Inaccuracy:** The end-of-game statistics were buggy; guess distribution consistently showed five guesses regardless of actual data.\n- **Performance Issues:** Moving app storage to Firebase for cross-device state management failed; I had to revert and manually update state only on submit/refresh.\n- **Design Inconsistency:** Every new card, modal, or tab slightly differed in shadow, corner rounding, padding, or margins.\n\nIt seemed every new feature required iterative back-and-forth to get exactly what I wanted.\n\n---\n\n## Project 3: ESP32 Embedded Wi-Fi Clock (C++/PlatformIO)\n\nMy final test was an [ESP32 embedded Wi-Fi clock project](https://github.com/AlexanderBiba/esp32-dotmatrix-wifi-clock). This C++ application, built using PlatformIO, drives a dot matrix display and runs a configuration web page in pure HTML/JS.\n\n![](esp32-clock.jpg)\n\nUsing the AI agent here was significantly more challenging. Most feature additions caused breakages requiring manual debugging:\n\n- Incompatible web page changes breaking server configurations.\n- Boot sequence changes preventing the device from turning on.\n- Settings object changes wiping stored data.\n- Style consistency issues on added web elements.\n\nDespite hurdles, I added some cool features:\n\n- **Revamped Web Page:** Light/dark modes\n- **New Screens:** Countdown, Rain effect (matrix style), IP address display\n- **Display Customization:** Screen order/duration, flip display\n- **System Features:** MDNS configuration, timezone/weather via Open-Meteo API, system info, reboot/factory reset\n\n|        Before         |        After         |\n| :-------------------: | :------------------: |\n| ![](esp32-before.png) | ![](esp32-after.png) |\n\n---\n\n## Conclusion\n\n### Pros and Cons Summary\n\n**Where it excels:**\n\n- **Cold Starts:** Excellent for bootstrapping new projects.\n- **Small, Precise Enhancements:** Handles minor, targeted improvements.\n- **General Cleanup:** Safely removes code and dependencies.\n\n**Where it falls short:**\n\n- **Maintaining Consistency:** Tends to reinvent patterns unless explicitly instructed.\n- **Large-Scale Enhancements:** Needs very specific prompts for complex features.\n- **Code Quality:** Output can be brittle, narrowly tailored, and non-generic.\n\n### Tips for Using AI Coding Agents Effectively\n\n- **Start Fresh Often:** Long threads can spiral; restart to improve results.\n- **Revert and Rephrase:** Roll back and restate goals rather than patching incrementally.\n- **Provide Clear Context:** Point to specific files or entry points.\n- **Be Extremely Specific:** Clarity directly improves output quality.\n- **Leverage Project Rules:** Use `.cursor/rules` for project-wide consistency.\n- **Enjoy the Process:** Mastering the tool takes experimentation, but it’s rewarding.\n"
  },
  {
    "slug": "welcome-post",
    "title": "Welcome to My Blog",
    "date": "2025-11-01",
    "description": "",
    "ogImage": null,
    "content": "\nWelcome!\n\nI’m excited to share this space where I write about software development, projects I’m working on, and insights I gain along the way. All the content you’ll find here is **entirely my own**, reflecting my experiences, thoughts, and perspectives.\n\nThat said, to make my posts clearer and easier to read, I sometimes use AI tools to **proofread and rephrase** sentences for clarity and flow. The ideas, opinions, and technical content are fully authored by me, the AI is just helping me make the writing more polished.\n\nThis blog is for anyone interested in software, coding experiments, 3D printing, and other projects I enjoy exploring. I hope you find the content useful, informative, and occasionally entertaining.\n\nThanks for visiting, and I look forward to sharing more soon!\n"
  }
];

export const getPostBySlug = (slug: string): BlogPost | undefined => {
    return posts.find(post => post.slug === slug);
};

export const getAllPosts = (): BlogPost[] => {
    return posts;
};

export const getLatestPosts = (limit: number = 3): BlogPost[] => {
    return posts.slice(0, limit);
};
