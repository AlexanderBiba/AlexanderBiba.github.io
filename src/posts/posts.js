// This file is auto-generated by scripts/build-posts.js
// Do not edit manually

export const posts = [
  {
    "slug": "cursor-experience",
    "title": "My Honest Experience with Cursor",
    "date": "2025-11-02",
    "content": "\nI’ve been writing code since I was a kid. Autocompletion has been a constant companion, and I was genuinely impressed when GitHub Copilot arrived, offering context-aware, AI-driven suggestions.\n\nTo be honest, I was a latecomer to the \"vibe coding\" hype train. When my workplace provided us with Cursor licenses, I was initially skeptical. I felt more productive sticking to my traditional, \"old-fashioned\" way of writing code, and, frankly, I didn't want to risk my project deadlines on a new tool.\n\nHowever, things changed during my paternity leave. I decided to dedicate some time to truly learn how to \"vibe code,\" and I was absolutely blown away. Below is my experience.\n\n## Project 1: Personal Website (React/GitHub Pages)\n\nMy first task was improving my [personal website](https://alexanderbiba.github.io/), a small React application hosted on GitHub Pages. I was hooked from the very first prompt:\n\n> “This is my personal website; it looks a bit dated. Can we make it look modern and cool? Specifically, I would like a retro-futuristic theme and a dark mode/light mode button.”\n\nThe initial result was... okay. A little infantile, perhaps, as \"retro-futuristic\" wasn't quite my style. But in that moment, I understood the agent's potential. My next prompt was:\n\n> \"Actually, make it more professional, minimalistic, and concise, while still surfacing the most relevant information.\"\n\nI followed up with more specific requests:\n\n- \"this section is unnecessary\"\n- \"make the experience part card-based\"\n- \"let’s try a dark style\"\n\nAfter several rounds of back-and-forth, I reached an outcome I was satisfied with. Crucially, the process itself was fun, allowing me to experiment with different styles, prompts, and ideas.\n\n|         Before         |         After         |\n| :--------------------: | :-------------------: |\n| ![](mysite-before.png) | ![](mysite-after.png) |\n\n---\n\n## Project 2: Wordle Clone (React/Firebase)\n\nThe next project was a slightly more complex React/Firebase application, a [Wordle clone](https://alexanderbiba.github.io/wordle/). Here, I moved beyond just style updates (though it definitely got a facelift) to adding substantial new features. The basic app was bare-bones: a daily word, five attempts, all stored in browser cache. With the AI agent, I was able to implement:\n\n- **Profiles:** Sign-in functionality using a Google account.\n- **End-of-Game Statistics:** Metrics like games played, current streak, win percentage, and guess distribution.\n- **Leaderboard:** Displaying leaders across the above statistics.\n- **Information:** Game instructions and an \"About\" section.\n\nThe agent was even helpful with backend configuration, guiding me on which Firebase settings needed updating to support the new login flow.\n\n|         Before         |         After         |\n| :--------------------: | :-------------------: |\n| ![](wordle-before.png) | ![](wordle-after.png) |\n\nDespite these awesome features, this is where I started encountering quirks:\n\n- **Minor CSS Glitches:** The initial dark mode button worked, but when zoomed out, white bars appeared where the page should have been dark.\n- **Feature Implementation Complexity:** Redesigning the keyboard took several attempts; the agent initially placed it outside the card, then created two keyboards.\n- **Data Inaccuracy:** The end-of-game statistics were buggy; guess distribution consistently showed five guesses regardless of actual data.\n- **Performance Issues:** Moving app storage to Firebase for cross-device state management failed; I had to revert and manually update state only on submit/refresh.\n- **Design Inconsistency:** Every new card, modal, or tab slightly differed in shadow, corner rounding, padding, or margins.\n\nIt seemed every new feature required iterative back-and-forth to get exactly what I wanted.\n\n---\n\n## Project 3: ESP32 Embedded Wi-Fi Clock (C++/PlatformIO)\n\nMy final test was an [ESP32 embedded Wi-Fi clock project](https://github.com/AlexanderBiba/esp32-dotmatrix-wifi-clock). This C++ application, built using PlatformIO, drives a dot matrix display and runs a configuration web page in pure HTML/JS.\n\nUsing the AI agent here was significantly more challenging. Most feature additions caused breakages requiring manual debugging:\n\n- Incompatible web page changes breaking server configurations.\n- Boot sequence changes preventing the device from turning on.\n- Settings object changes wiping stored data.\n- Style consistency issues on added web elements.\n\nDespite hurdles, I added some cool features:\n\n- **Revamped Web Page:** Light/dark modes\n- **New Screens:** Countdown, Rain effect (matrix style), IP address display\n- **Display Customization:** Screen order/duration, flip display\n- **System Features:** MDNS configuration, timezone/weather via Open-Meteo API, system info, reboot/factory reset\n\n|        Before         |        After         |\n| :-------------------: | :------------------: |\n| ![](esp32-before.png) | ![](esp32-after.png) |\n\n---\n\n## Conclusion\n\n### Pros and Cons Summary\n\n**Where it excels:**\n\n- **General Cleanup:** Safely removes code and dependencies.\n- **Small, Precise Enhancements:** Handles minor, targeted improvements.\n- **Cold Starts:** Excellent for bootstrapping new projects.\n\n**Where it falls short:**\n\n- **Maintaining Consistency:** Tends to reinvent patterns unless explicitly instructed.\n- **Large-Scale Enhancements:** Needs very specific prompts for complex features.\n- **Code Quality:** Output can be brittle, narrowly tailored, and non-generic.\n\n### Tips for Using AI Coding Agents Effectively\n\n- **Start Fresh Often:** Long threads can spiral; restart to improve results.\n- **Revert and Rephrase:** Roll back and restate goals rather than patching incrementally.\n- **Provide Clear Context:** Point to specific files or entry points.\n- **Be Extremely Specific:** Clarity directly improves output quality.\n- **Leverage Project Rules:** Use `.cursor/rules` for project-wide consistency.\n- **Enjoy the Process:** Mastering the tool takes experimentation, but it’s rewarding.\n\n**Bottom line:**  \nTools like Cursor aren’t just the future of development, they’re already reshaping the present. They amplify developers rather than replace them. Stay specific, stay consistent, and enjoy the ride!\n"
  },
  {
    "slug": "welcome-post",
    "title": "Welcome to My Blog",
    "date": "2025-11-02",
    "content": "\nWelcome!  \n\nI’m excited to share this space where I write about software development, projects I’m working on, and insights I gain along the way. All the content you’ll find here is **entirely my own**, reflecting my experiences, thoughts, and perspectives.  \n\nThat said, to make my posts clearer and easier to read, I sometimes use AI tools to **proofread and rephrase** sentences for clarity and flow. The ideas, opinions, and technical content are fully authored by me — the AI is just helping me make the writing more polished.  \n\nThis blog is for anyone interested in software, coding experiments, 3D printing, and other projects I enjoy exploring. I hope you find the content useful, informative, and occasionally entertaining.  \n\nThanks for visiting, and I look forward to sharing more soon!  \n"
  }
];

export const getPostBySlug = (slug) => {
    return posts.find(post => post.slug === slug);
};

export const getAllPosts = () => {
    return posts;
};

export const getLatestPosts = (limit = 3) => {
    return posts.slice(0, limit);
};
