const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

const postsDir = path.join(__dirname, '../src/posts');
const outputFile = path.join(__dirname, '../src/posts/posts.ts');
const srcImagesDir = path.join(__dirname, '../src/assets/blog-images');
const publicImagesDir = path.join(__dirname, '../public/blog-images');

// Format date as YYYY-MM-DD
function formatDate(date) {
    if (!date) {
        const now = new Date();
        return now.toISOString().split('T')[0];
    }
    
    // If it's already in YYYY-MM-DD format, return as is
    if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return date;
    }
    
    // Otherwise, parse and format
    const dateObj = new Date(date);
    return dateObj.toISOString().split('T')[0];
}

// Get all markdown files from posts directory (exclude README.md)
const files = fs.readdirSync(postsDir).filter(file => 
    file.endsWith('.md') && !file.toLowerCase().includes('readme')
);

const posts = [];

files.forEach(file => {
    const filePath = path.join(postsDir, file);
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const { data, content } = matter(fileContent);
    
    // Extract title from first line starting with single '#'
    let title = data.title || 'Untitled';
    let processedContent = content;
    
    // Find first line that starts with exactly '# ' (single hash followed by space)
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.trim().startsWith('# ')) {
            // Extract title (remove '# ' prefix and trim)
            title = line.trim().substring(2).trim();
            // Remove the title line from content
            lines.splice(i, 1);
            // If there's an empty line after the title, remove it too
            if (i < lines.length && lines[i].trim() === '') {
                lines.splice(i, 1);
            }
            processedContent = lines.join('\n');
            break;
        }
    }
    
    const slug = file.replace('.md', '');
    posts.push({
        slug,
        title,
        date: formatDate(data.date),
        description: data.description || '',
        ogImage: data.ogImage || null,
        content: processedContent
    });
});

// Sort by date (newest first)
posts.sort((a, b) => new Date(b.date) - new Date(a.date));

// Generate the posts.ts file
const output = `// This file is auto-generated by scripts/build-posts.js
// Do not edit manually

import { BlogPost } from './types'

export const posts: BlogPost[] = ${JSON.stringify(posts, null, 2)};

export const getPostBySlug = (slug: string): BlogPost | undefined => {
    return posts.find(post => post.slug === slug);
};

export const getAllPosts = (): BlogPost[] => {
    return posts;
};

export const getLatestPosts = (limit: number = 3): BlogPost[] => {
    return posts.slice(0, limit);
};
`;

fs.writeFileSync(outputFile, output, 'utf-8');
console.log(`✓ Generated posts.ts with ${posts.length} posts`);

// Copy blog images from src/assets/blog-images to public/blog-images
if (fs.existsSync(srcImagesDir)) {
    // Ensure public/blog-images directory exists
    if (!fs.existsSync(publicImagesDir)) {
        fs.mkdirSync(publicImagesDir, { recursive: true });
    }
    
    // Copy all image files
    const imageFiles = fs.readdirSync(srcImagesDir).filter(file => 
        /\.(jpg|jpeg|png|gif|webp|svg)$/i.test(file)
    );
    
    imageFiles.forEach(file => {
        const srcPath = path.join(srcImagesDir, file);
        const destPath = path.join(publicImagesDir, file);
        fs.copyFileSync(srcPath, destPath);
    });
    
    if (imageFiles.length > 0) {
        console.log(`✓ Copied ${imageFiles.length} image(s) to public/blog-images/`);
    }
}

